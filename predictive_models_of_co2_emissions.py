# -*- coding: utf-8 -*-
"""Predictive Models of CO2 Emissions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A1QzAUvvhNhfiCxiL_KR8z236vcJZycQ

##Pridicting CO2 Emmisions Using Regression
"""

# Commented out IPython magic to ensure Python compatibility.
#Import important libaries
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
# %matplotlib inline

#import the csv data file from to your google colab noteboke from your computer
from google.colab import files
Updated=files.upload()

df=pd.read_csv('Fuel.csv', sep=',')
df.head(10)

df.describe()

missing_data=df.isnull()
missing_data.head(5)

cdf = df[['ENGINESIZE','CYLINDERS','FUELCONSUMPTION_COMB','CO2EMISSIONS']]
cdf.head(9)

import matplotlib.pyplot as plt
import seaborn as sns

columns_to_plot = ['CO2EMISSIONS', 'CYLINDERS', 'FUELCONSUMPTION_COMB', 'ENGINESIZE']

for col in columns_to_plot:
    plt.figure(figsize=(4, 2)) # Create a new figure for each plot
    sns.histplot(data=cdf, x=col, kde=True) # Use histplot with the column name
    plt.title(f'Distribution of {col}')
    plt.xlabel(col)
    plt.ylabel('Frequency')
    plt.show()

sns.scatterplot(x='FUELCONSUMPTION_COMB', y='CO2EMISSIONS', color='red', data=cdf)

sns.scatterplot(x='ENGINESIZE', y='CO2EMISSIONS', color='red', data=cdf)

sns.scatterplot(x='CYLINDERS', y='CO2EMISSIONS', color='red', data=cdf)

"""##Model Training"""

#install specific version of libraries used in lab
import pandas as pd
import numpy as np
import sklearn
import matplotlib.pyplot as plt

from sklearn.linear_model import LinearRegression #loading modules for linear regression
model= LinearRegression() #creating a linear regression model
model

"""###Model Evaluation and Training"""

from sklearn.model_selection import train_test_split

# Split the data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(cdf[['ENGINESIZE']], cdf['CO2EMISSIONS'], test_size=0.2, random_state=42)

# Train the model using the training data
model.fit(x_train, y_train)

print("Model training complete.")
# The coefficients
print ('Coefficients: ', model.coef_)
print ('Intercept: ',model.intercept_)

# Assuming x_train is a DataFrame and y_train is a Series
plt.scatter(x_train['ENGINESIZE'], y_train,  color='blue', label='Training Data')

# Plot the linear regression line
# Create a range of values for engine size to plot the line
line_x = np.linspace(x_train['ENGINESIZE'].min(), x_train['ENGINESIZE'].max(), 100)
line_y = model.coef_[0] * line_x + model.intercept_
plt.plot(line_x, line_y, '-r', label='Regression Line')

plt.xlabel("Engine size")
plt.ylabel("Emission")
plt.title("CO2 Emissions vs Engine Size (Training Data)")
plt.legend()
plt.show()

"""###Model Prediction"""

# Make predictions using the trained model
yhat = model.predict(x_test)

print(yhat)

"""###Model Evalution"""

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

# Calculate evaluation metrics
mae = mean_absolute_error(y_test, yhat)
mse = mean_squared_error(y_test, yhat)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, yhat)

print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"Mean Squared Error (MSE): {mse:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"R-squared (R²): {r2:.2f}")

"""##Multiple Linear Regression

###Model Evaluation and Training
"""

from sklearn.model_selection import train_test_split

# Split the data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(cdf[['ENGINESIZE','CYLINDERS','FUELCONSUMPTION_COMB']], cdf['CO2EMISSIONS'], test_size=0.2, random_state=42)

# Train the model using the training data
model.fit(x_train, y_train)

print("Model training complete.")
# The coefficients
print ('Coefficients: ', model.coef_)
print ('Intercept: ',model.intercept_)

"""###Model Prediction"""

# Make predictions using the trained model
yhat = model.predict(x_test)

print(yhat)

"""###Model Evaluation"""

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

# Calculate evaluation metrics
mae = mean_absolute_error(y_test, yhat)
mse = mean_squared_error(y_test, yhat)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, yhat)

print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"Mean Squared Error (MSE): {mse:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"R-squared (R²): {r2:.2f}")

"""##Polinomial Regression

###Model Evaluation and Training
"""

from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

# Split the data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(cdf[['ENGINESIZE']], cdf['CO2EMISSIONS'], test_size=0.2, random_state=42)

# Create polynomial features
# You can adjust the 'degree' parameter to control the degree of the polynomial
poly = PolynomialFeatures(degree=2) # Example: degree 2 for a quadratic relationship
x_train_poly = poly.fit_transform(x_train)
x_test_poly = poly.transform(x_test)

# Train a Linear Regression model on the polynomial features
poly_model = LinearRegression()
poly_model.fit(x_train_poly, y_train)

print("Polynomial Regression Model training complete.")
# The coefficients
print ('Coefficients: ', poly_model.coef_)
print ('Intercept: ',poly_model.intercept_)

"""###Prediction"""

# Make predictions using the trained model
yhat = poly_model.predict(x_test_poly)

print(yhat)

# Assuming x_train is a DataFrame and y_train is a Series
plt.scatter(x_train['ENGINESIZE'], y_train,  color='blue', label='Training Data')

# Plot the polynomial regression line
# Create a range of values for engine size to plot the line
line_x = np.linspace(x_train['ENGINESIZE'].min(), x_train['ENGINESIZE'].max(), 100).reshape(-1, 1) # Reshape for polynomial transformation
line_x_poly = poly.transform(line_x) # Transform into polynomial features

# Calculate the predicted y values using the polynomial model
line_y = poly_model.predict(line_x_poly)

plt.plot(line_x, line_y, '-r', label='Polynomial Regression Line')

plt.xlabel("Engine size")
plt.ylabel("Emission")
plt.title("CO2 Emissions vs Engine Size (Training Data)")
plt.legend()
plt.show()

"""##Model Evaluation"""

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

# Assuming y_test contains the actual values and yhat_poly contains the predictions from the polynomial model

# Calculate evaluation metrics for the polynomial regression model
mae_poly = mean_absolute_error(y_test, yhat_poly)
mse_poly = mean_squared_error(y_test, yhat_poly)
rmse_poly = np.sqrt(mse_poly)
r2_poly = r2_score(y_test, yhat_poly)

print(f"Polynomial Model - Mean Absolute Error (MAE): {mae_poly:.2f}")
print(f"Polynomial Model - Mean Squared Error (MSE): {mse_poly:.2f}")
print(f"Polynomial Model - Root Mean Squared Error (RMSE): {rmse_poly:.2f}")
print(f"Polynomial Model - R-squared (R²): {r2_poly:.2f}")

